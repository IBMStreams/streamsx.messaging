/*******************************************************************************
 * Copyright (C) 2015, MOHAMED-ALI SAID
 * All Rights Reserved
 *******************************************************************************/
/* Generated by Streams Studio: March 26, 2014 11:37:11 AM EDT */
package com.ibm.streamsx.messaging.rabbitmq;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;
import java.util.logging.Logger;

import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.logging.TraceLevel;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;
import com.rabbitmq.client.AMQP.BasicProperties;

/**
 * This operator was originally contributed by Mohamed-Ali Said @saidmohamedali
 * Class for an operator that consumes tuples and does not produce an output
 * stream. This pattern supports a number of input streams and no output
 * streams.
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to
 * process and submit tuples</li>
 * <li>process() handles a tuple arriving on an input port
 * <li>processPuncuation() handles a punctuation mark arriving on an input port
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any
 * time, such as a request to stop a PE or cancel a job. Thus the shutdown() may
 * occur while the operator is processing tuples, punctuation marks, or even
 * during port ready notification.</li>
 * </ul>
 * <p>
 * With the exception of operator initialization, all the other events may occur
 * concurrently with each other, which lead to these methods being called
 * concurrently by different threads.
 * </p>
 */
@InputPorts(@InputPortSet(cardinality = 1, optional = false, description = ""))
@PrimitiveOperator(name = "RabbitMQSink", description = "something")
public class RabbitMQSink extends RabbitBaseOper {

	private final Logger trace = Logger.getLogger(RabbitMQSink.class
			.getCanonicalName());
	Integer deliveryMode = 1;
	int maxMessageSendRetries = 0;
	int messageSendRetryDelay = 10000;
	/**
	 * Initialize this operator. Called once before any tuples are processed.
	 * 
	 * @param context
	 *            OperatorContext for this operator.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void initialize(OperatorContext context)
			throws Exception {

		// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
		super.initSchema(getInput(0).getStreamSchema());
		trace.log(TraceLevel.INFO, "Operator " + context.getName() + " initializing in PE: "
				+ context.getPE().getPEId() + " in Job: "
				+ context.getPE().getJobId());

	}

	/**
	 * Notification that initialization is complete and all input and output
	 * ports are connected and ready to receive and submit tuples.
	 * 
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void allPortsReady() throws Exception {
		// This method is commonly used by source operators.
		// Operators that process incoming tuples generally do not need this
		// notification.
		OperatorContext context = getOperatorContext();
		trace.log(TraceLevel.INFO, "Operator " + context.getName()
				+ " all ports are ready in PE: " + context.getPE().getPEId()
				+ " in Job: " + context.getPE().getJobId());

	}

	/**
	 * Process an incoming tuple that arrived on the specified port.
	 * 
	 * @param stream
	 *            Port the tuple is arriving on.
	 * @param tuple
	 *            Object representing the incoming tuple.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void process(StreamingInput<Tuple> stream, Tuple tuple) throws Exception
			{

		String message = tuple.getString(messageAH.getName());
		String routingKey = "";
		Map<String, Object> headers = new HashMap<String,Object>();
		
		if (routingKeyAH.isAvailable()){
			routingKey = tuple.getString(routingKeyAH.getName());
		}
		
		BasicProperties.Builder propsBuilder = new BasicProperties.Builder();
		
		if (messageHeaderAH.isAvailable()){
			headers = (Map<String, Object>) tuple.getMap(messageHeaderAH.getName());
			propsBuilder.headers(headers);
		}
		propsBuilder.deliveryMode(deliveryMode);
		
		try {
			trace.log(TraceLevel.TRACE, "Producing message: " + message + " in thread: "
					+ Thread.currentThread().getName());
			channel.basicPublish(exchangeName, routingKey, propsBuilder.build(),
					message.getBytes());
		} catch (Exception e) {
			trace.log(TraceLevel.ERROR, "Exception message:" + e.getMessage() + "\r\n");
			Boolean failedToSend = true;
			int attemptCount = 0;
			while (failedToSend
					&& attemptCount < maxMessageSendRetries){
				try {
					Thread.sleep(messageSendRetryDelay);
					trace.log(TraceLevel.ERROR, "Attempting to resend. Try number: " + attemptCount);
					channel.basicPublish(exchangeName, routingKey, propsBuilder.build(),
							message.getBytes());
					failedToSend = false;
				} catch (InterruptedException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (Exception e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				attemptCount++;
			}
			
			//if we still can't send after the number of maxMessageSendRetries, we want to fail
			if (failedToSend){
				trace.log(TraceLevel.ERROR, "Failed to send message after " + attemptCount + " attempts.");
			}
			
		} 
	}

	@Parameter(optional = true, description = "Marks message as persistent(2) or non-persistent(1). Default as 1. ")
	public void setDeliveryMode(Integer value) {
		deliveryMode = value; 
	}
	
	@Parameter(optional = true, description = "This optional parameter specifies the number of successive retries that are attempted for a message if a failure occurs when the message is sent. The default value is zero; no retries are attempted.")
	public void setMaxMessageSendRetries(int value) {
		maxMessageSendRetries = value; 
	}
	
	@Parameter(optional = true, description = "This optional parameter specifies the time in milliseconds to wait before the next delivery attempt. If the maxMessageSendRetries is specified, you must also specify a value for this parameter.")
	public void setMessageSendRetryDelay(int value) {
		messageSendRetryDelay = value; 
	}

	
	/**
	 * Shutdown this operator.
	 * 
	 * @throws TimeoutException
	 * @throws IOException
	 */
	@Override
	public synchronized void shutdown() throws IOException, TimeoutException {
		super.shutdown();
	}
	

}
